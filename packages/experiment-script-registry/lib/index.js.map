{"version":3,"sources":["../src/index.ts"],"names":["createScriptRegistry","payload","map","Map","Object","keys","forEach","k","set","extend","newPayload","newScript","key","args","config","get","undefined","Error","code_hash","CODE_HASH","hash_type","HASH_TYPE","serializeJson","isScriptOf","script","newCellDep","out_point","tx_hash","TX_HASH","index","INDEX","dep_type","DEP_TYPE","nameOfScript","name","value"],"mappings":";;;;;;;AAYO,SAASA,oBAAT,CACLC,OADK,EAEc;AACnB,QAAMC,GAA2C,GAAG,IAAIC,GAAJ,EAApD;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYJ,OAAZ,EAAqBK,OAArB,CAA8BC,CAAD,IAAOL,GAAG,CAACM,GAAJ,CAAQD,CAAR,EAAWN,OAAO,CAACM,CAAD,CAAlB,CAApC;;AAEA,QAAME,MAAM,GAA8BC,UAA3B,IAA8C;AAC3D,WAAOV,oBAAoB,CAAC,EAAE,GAAGC,OAAL;AAAc,SAAGS;AAAjB,KAAD,CAA3B;AACD,GAFD;;AAIA,QAAMC,SAAS,GAAG,CAACC,GAAD,EAAeC,IAAf,KAAyC;AACzD,UAAMC,MAAM,GAAGZ,GAAG,CAACa,GAAJ,CAAQH,GAAR,CAAf;AACA,QAAIE,MAAM,KAAKE,SAAf,EACE,MAAM,IAAIC,KAAJ,CAAW,GAAEL,GAAI,kCAAjB,CAAN;;AACF,QAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAO;AACLK,QAAAA,SAAS,EAAEJ,MAAM,CAACK,SADb;AAELC,QAAAA,SAAS,EAAEN,MAAM,CAACO,SAFb;AAGLR,QAAAA,IAAI,EAAEA;AAHD,OAAP;AAKD,KAND,MAMO;AACL,aAAO;AACLK,QAAAA,SAAS,EAAEJ,MAAM,CAACK,SADb;AAELC,QAAAA,SAAS,EAAEN,MAAM,CAACO,SAFb;AAGLR,QAAAA,IAAI,EAAEA,IAAI,CAACS,aAAL;AAHD,OAAP;AAKD;AACF,GAjBD;;AAmBA,QAAMC,UAAU,GAAG,CAACX,GAAD,EAAeY,MAAf,KAAkC;AACnD,UAAMV,MAAM,GAAGZ,GAAG,CAACa,GAAJ,CAAQH,GAAR,CAAf;AACA,QAAIE,MAAM,KAAKE,SAAf,EACE,MAAM,IAAIC,KAAJ,CAAW,GAAEL,GAAI,kCAAjB,CAAN;AACF,WACEY,MAAM,CAACN,SAAP,KAAqBJ,MAAM,CAACK,SAA5B,IACAK,MAAM,CAACJ,SAAP,KAAqBN,MAAM,CAACO,SAF9B;AAID,GARD;;AAUA,QAAMI,UAAU,GAAIb,GAAD,IAAkB;AACnC,UAAME,MAAM,GAAGZ,GAAG,CAACa,GAAJ,CAAQH,GAAR,CAAf;AACA,QAAIE,MAAM,KAAKE,SAAf,EACE,MAAM,IAAIC,KAAJ,CAAW,GAAEL,GAAI,kCAAjB,CAAN;AACF,WAAO;AACLc,MAAAA,SAAS,EAAE;AACTC,QAAAA,OAAO,EAAEb,MAAM,CAACc,OADP;AAETC,QAAAA,KAAK,EAAEf,MAAM,CAACgB;AAFL,OADN;AAKLC,MAAAA,QAAQ,EAAEjB,MAAM,CAACkB;AALZ,KAAP;AAOD,GAXD;;AAaA,QAAMC,YAAY,GAAIT,MAAD,IAAoB;AACvC,QAAIU,IAAI,GAAGlB,SAAX;AACAd,IAAAA,GAAG,CAACI,OAAJ,CAAY,CAAC6B,KAAD,EAAQvB,GAAR,KAAgB;AAC1B,UACEY,MAAM,CAACN,SAAP,MAAqBiB,KAArB,aAAqBA,KAArB,uBAAqBA,KAAK,CAAEhB,SAA5B,KACAK,MAAM,CAACJ,SAAP,KAAqBe,KAAK,CAACd,SAF7B,EAGE;AACAa,QAAAA,IAAI,GAAGtB,GAAP;AACD;AACF,KAPD;AAQA,WAAOsB,IAAP;AACD,GAXD;;AAaA,SAAO;AACLzB,IAAAA,MAAM,EAAEA,MADH;AAELE,IAAAA,SAAS,EAAEA,SAFN;AAGLY,IAAAA,UAAU,EAAEA,UAHP;AAILE,IAAAA,UAAU,EAAEA,UAJP;AAKLQ,IAAAA,YAAY,EAAEA;AALT,GAAP;AAOD","sourcesContent":["import { Script, CellDep } from \"@ckb-lumos/base\";\nimport { ScriptConfig, ScriptConfigs } from \"@ckb-lumos/config-manager\";\nimport { Reader } from \"@ckb-lumos/toolkit\";\n\ninterface ScriptRegistry<T extends ScriptConfigs> {\n  extend: <T1 extends ScriptConfigs>(newPayload: T1) => ScriptRegistry<T & T1>;\n  newScript: (key: keyof T, args: string | Reader) => Script;\n  isScriptOf: (key: keyof T, script: Script) => boolean;\n  newCellDep: (key: keyof T) => CellDep;\n  nameOfScript: (script: Script) => keyof T | undefined;\n}\n\nexport function createScriptRegistry<T extends ScriptConfigs>(\n  payload: T\n): ScriptRegistry<T> {\n  const map: Map<keyof T, ScriptConfig | undefined> = new Map();\n  Object.keys(payload).forEach((k) => map.set(k, payload[k]));\n\n  const extend = <T1 extends ScriptConfigs>(newPayload: T1) => {\n    return createScriptRegistry({ ...payload, ...newPayload });\n  };\n\n  const newScript = (key: keyof T, args: string | Reader) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    if (typeof args === \"string\") {\n      return {\n        code_hash: config.CODE_HASH,\n        hash_type: config.HASH_TYPE,\n        args: args,\n      };\n    } else {\n      return {\n        code_hash: config.CODE_HASH,\n        hash_type: config.HASH_TYPE,\n        args: args.serializeJson(),\n      };\n    }\n  };\n\n  const isScriptOf = (key: keyof T, script: Script) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    return (\n      script.code_hash === config.CODE_HASH &&\n      script.hash_type === config.HASH_TYPE\n    );\n  };\n\n  const newCellDep = (key: keyof T) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    return {\n      out_point: {\n        tx_hash: config.TX_HASH,\n        index: config.INDEX,\n      },\n      dep_type: config.DEP_TYPE,\n    };\n  };\n\n  const nameOfScript = (script: Script) => {\n    let name = undefined;\n    map.forEach((value, key) => {\n      if (\n        script.code_hash === value?.CODE_HASH &&\n        script.hash_type === value.HASH_TYPE\n      ) {\n        name = key;\n      }\n    });\n    return name;\n  };\n\n  return {\n    extend: extend,\n    newScript: newScript,\n    isScriptOf: isScriptOf,\n    newCellDep: newCellDep,\n    nameOfScript: nameOfScript,\n  };\n}\n"],"file":"index.js"}