{"version":3,"sources":["../src/index.ts"],"names":["createScriptRegistry","payload","map","Map","Object","keys","forEach","k","set","extend","newPayload","newScript","key","args","config","get","undefined","Error","code_hash","CODE_HASH","hash_type","HASH_TYPE","serializeJson","isScriptOf","script","newCellDep","out_point","tx_hash","TX_HASH","index","INDEX","dep_type","DEP_TYPE","nameOfScript","name","value","createCell","options","data","cellOutput","capacity","BI","from","toHexString","lock","type","assign","cell","cell_output","block_hash","block_number","skipCheckCapacityIsEnough","min","lt","createCellWithMinimalCapacity"],"mappings":"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","sourcesContent":["import {\n  Script,\n  CellDep,\n  HexString,\n  OutPoint,\n  Hash,\n  HexNumber,\n  Cell,\n} from \"@ckb-lumos/base\";\nimport { BI, BIish } from \"@ckb-lumos/bi\";\nimport { minimalCellCapacity } from \"@ckb-lumos/helpers\";\nimport { ScriptConfig, ScriptConfigs } from \"@ckb-lumos/config-manager\";\nimport { Reader } from \"@ckb-lumos/toolkit\";\n\ninterface ScriptRegistry<T extends ScriptConfigs> {\n  extend: <T1 extends ScriptConfigs>(newPayload: T1) => ScriptRegistry<T & T1>;\n  newScript: (key: keyof T, args: string | Reader) => Script;\n  isScriptOf: (key: keyof T, script: Script) => boolean;\n  newCellDep: (key: keyof T) => CellDep;\n  nameOfScript: (script: Script) => keyof T | undefined;\n}\n\nexport function createScriptRegistry<T extends ScriptConfigs>(\n  payload: T\n): ScriptRegistry<T> {\n  const map: Map<keyof T, ScriptConfig | undefined> = new Map();\n  Object.keys(payload).forEach((k) => map.set(k, payload[k]));\n\n  const extend = <T1 extends ScriptConfigs>(newPayload: T1) => {\n    return createScriptRegistry({ ...payload, ...newPayload });\n  };\n\n  const newScript = (key: keyof T, args: string | Reader) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    if (typeof args === \"string\") {\n      return {\n        code_hash: config.CODE_HASH,\n        hash_type: config.HASH_TYPE,\n        args: args,\n      };\n    } else {\n      return {\n        code_hash: config.CODE_HASH,\n        hash_type: config.HASH_TYPE,\n        args: args.serializeJson(),\n      };\n    }\n  };\n\n  const isScriptOf = (key: keyof T, script: Script) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    return (\n      script.code_hash === config.CODE_HASH &&\n      script.hash_type === config.HASH_TYPE\n    );\n  };\n\n  const newCellDep = (key: keyof T) => {\n    const config = map.get(key);\n    if (config === undefined)\n      throw new Error(`${key} doesn't exist in ScriptRegistry`);\n    return {\n      out_point: {\n        tx_hash: config.TX_HASH,\n        index: config.INDEX,\n      },\n      dep_type: config.DEP_TYPE,\n    };\n  };\n\n  const nameOfScript = (script: Script) => {\n    let name = undefined;\n    map.forEach((value, key) => {\n      if (\n        script.code_hash === value?.CODE_HASH &&\n        script.hash_type === value.HASH_TYPE\n      ) {\n        name = key;\n      }\n    });\n    return name;\n  };\n\n  return {\n    extend: extend,\n    newScript: newScript,\n    isScriptOf: isScriptOf,\n    newCellDep: newCellDep,\n    nameOfScript: nameOfScript,\n  };\n}\n\ninterface Payload {\n  lock: Script;\n  type?: Script;\n  capacity: BIish;\n  data?: HexString;\n  out_point?: OutPoint;\n  block_hash?: Hash;\n  block_number?: HexNumber;\n}\n\nexport function createCell(\n  payload: Payload,\n  options?: { skipCheckCapacityIsEnough?: boolean }\n): Cell {\n  const data = payload.data || \"0x\";\n  let cellOutput = {\n    capacity: BI.from(payload.capacity).toHexString(),\n    lock: payload.lock,\n  };\n  if (payload.type) {\n    cellOutput = Object.assign(cellOutput, { type: payload.type });\n  }\n  let cell = {\n    cell_output: cellOutput,\n    data: data,\n  };\n  if (payload.out_point) {\n    cell = Object.assign(cell, { out_point: payload.out_point });\n  }\n  if (payload.block_hash) {\n    cell = Object.assign(cell, { block_hash: payload.block_hash });\n  }\n  if (payload.block_number) {\n    cell = Object.assign(cell, { block_number: payload.block_number });\n  }\n  if (options?.skipCheckCapacityIsEnough !== false) {\n    const min = minimalCellCapacity(cell);\n    if (BI.from(payload.capacity).lt(min)) {\n      throw new Error(\"provided capacity is not enough\");\n    }\n  }\n  return cell;\n}\n\nexport function createCellWithMinimalCapacity(payload: {\n  lock: Script;\n  type?: Script;\n  data?: HexString;\n}): Cell {\n  const data = payload.data || \"0x\";\n  let cellOutput = {\n    capacity: \"0x0\",\n    lock: payload.lock,\n  };\n  if (payload.type) {\n    cellOutput = Object.assign(cellOutput, { type: payload.type });\n  }\n  const cell = {\n    cell_output: cellOutput,\n    data: data,\n  };\n  const min = minimalCellCapacity(cell);\n  cell.cell_output.capacity = BI.from(min).toHexString();\n  return cell;\n}\n"],"file":"index.js"}