import { bytes } from '@ckb-lumos/codec';
import {
  Indexer as CkbIndexer,
  helpers,
  Script,
  RPC,
  hd,
  config,
  Cell,
  commons,
  WitnessArgs,
  BI,
} from "@ckb-lumos/lumos";
import { values, blockchain } from "@ckb-lumos/base";
import { parseFromInfo, MultisigScript } from "@ckb-lumos/common-scripts/lib/from_info";
import { BIish } from "@ckb-lumos/bi";

const { ScriptValue } = values;

const { AGGRON4 } = config.predefined;

const CKB_RPC_URL = "https://testnet.ckb.dev/rpc";
const CKB_INDEXER_URL = "https://testnet.ckb.dev/indexer";
const rpc = new RPC(CKB_RPC_URL);
const indexer = new CkbIndexer(CKB_INDEXER_URL, CKB_RPC_URL);

const ALICE = {
  PRIVATE_KEY: "0x2c56a92a03d767542222432e4f2a0584f01e516311f705041d86b1af7573751f",
  ARGS: "0x3d35d87fac0008ba5b12ee1c599b102fc8f5fdf8",
};

const BOB = {
  PRIVATE_KEY: "0x3bc65932a75f76c5b6a04660e4d0b85c2d9b5114efa78e6e5cf7ad0588ca09c8",
  ARGS: "0x99dbe610c43186696e1f88cb7b59252d4c92afda",
};

const CHARLES = {
  PRIVATE_KEY: "0xbe06025fbd8c74f65a513a28e62ac56f3227fcb307307a0f2a0ef34d4a66e81f",
  ARGS: "0xc055df68fdd47c6a5965b9ab21cd6825d8696a76",
};

const TO_ADDRESS = "ckt1qyqptxys5l9vk39ft0hswscxgseawc77y2wqlr558h";

/**
 * Generate fromInfo for multisig transfer.
 * @param R The provided signatures must match at least the first R items of the Pubkey list.
 * @param M M of N signatures must be provided to unlock the cell. N equals to the size of publicKeyHashes.
 * @param publicKeyHashes The list of Lock Args generated by the blake160 function that extracts
 * the first 20 bytes of a public key hash.
 *
 * R, M are single byte unsigned integers that ranges from 0 to 255.
 * R must no more than M.
 */
function generateMofNMultisigInfo(R: number, M: number, publicKeyHashes: string[]): MultisigScript {
  return {
    R,
    M,
    publicKeyHashes,
  };
}

type Account = {
  fromScript: Script;
  multisigScript: string | undefined;
};

function generateAccountFromMultisigInfo(fromInfo: MultisigScript): Account {
  const { fromScript, multisigScript } = parseFromInfo(fromInfo, {
    config: AGGRON4,
  });
  return {
    fromScript,
    multisigScript,
  };
}

interface Options {
  fromInfo: MultisigScript;
  toAddress: string;
  amount: BIish;
  privKeys: string[];
}

export async function transfer(options: Options): Promise<string> {
  let txSkeleton = helpers.TransactionSkeleton({});

  const { fromScript, multisigScript } = generateAccountFromMultisigInfo(options.fromInfo);
  const toScript = helpers.parseAddress(options.toAddress, { config: AGGRON4 });

  // additional 0.001 ckb for tx fee
  // the tx fee could calculated by tx size
  // this is just a simple example
  const neededCapacity = BI.from(options.amount).add(100000);
  let collectedSum = BI.from(0);
  const collected: Cell[] = [];
  const collector = indexer.collector({ lock: fromScript, type: "empty" });
  for await (const cell of collector.collect()) {
    collectedSum = collectedSum.add(cell.cellOutput.capacity);
    collected.push(cell);
    if (collectedSum >= neededCapacity) break;
  }

  if (collectedSum < neededCapacity) {
    throw new Error("Not enough CKB");
  }

  const transferOutput: Cell = {
    cellOutput: {
      capacity: BI.from(options.amount).toHexString(),
      lock: toScript,
    },
    data: "0x",
  };

  const changeOutput: Cell = {
    cellOutput: {
      capacity: collectedSum.sub(neededCapacity).toHexString(),
      lock: fromScript,
    },
    data: "0x",
  };

  txSkeleton = txSkeleton.update("inputs", (inputs) => inputs.push(...collected));
  txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(transferOutput, changeOutput));
  txSkeleton = txSkeleton.update("cellDeps", (cellDeps) =>
    cellDeps.push({
      outPoint: {
        txHash: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.TX_HASH,
        index: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.INDEX,
      },
      depType: AGGRON4.SCRIPTS.SECP256K1_BLAKE160_MULTISIG.DEP_TYPE,
    })
  );

  const firstIndex = txSkeleton
    .get("inputs")
    .findIndex((input) =>
      new ScriptValue(input.cellOutput.lock, { validate: false }).equals(
        new ScriptValue(fromScript, { validate: false })
      )
    );
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
    }
    let witness: string = txSkeleton.get("witnesses").get(firstIndex)!;
    let newWitnessArgs: WitnessArgs;
    const SECP_SIGNATURE_PLACEHOLDER =
      "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

    newWitnessArgs = {
      lock: "0x" + multisigScript!.slice(2) + SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(options.fromInfo.M),
    };

    if (witness !== "0x") {
      const witnessArgs = blockchain.WitnessArgs.unpack(bytes.bytify(witness))
      const lock = witnessArgs.lock;
      if (!!lock && !!newWitnessArgs.lock && !bytes.equal(lock, newWitnessArgs.lock)) {
        throw new Error("Lock field in first witness is set aside for signature!");
      }
      const inputType = witnessArgs.inputType;
      if (!!inputType) {
        newWitnessArgs.inputType = inputType;
      }
      const outputType = witnessArgs.outputType;
      if (!!outputType) {
        newWitnessArgs.outputType = outputType;
      }
    }
    witness = bytes.hexify(blockchain.WitnessArgs.pack(newWitnessArgs))
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
  }

  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);
  const message = txSkeleton.get("signingEntries").get(0)?.message;

  let pubkeyHashN: string = "";
  options.fromInfo.publicKeyHashes.forEach((publicKeyHash) => {
    pubkeyHashN += publicKeyHash.slice(2);
  });

  let sigs: string = "";
  options.privKeys.forEach((privKey) => {
    if (privKey !== "") {
      let sig = hd.key.signRecoverable(message!, privKey);
      sig = sig.slice(2);
      sigs += sig;
    }
  });

  sigs =
    "0x00" +
    ("00" + options.fromInfo.R.toString(16)).slice(-2) +
    ("00" + options.fromInfo.M.toString(16)).slice(-2) +
    ("00" + options.fromInfo.publicKeyHashes.length.toString(16)).slice(-2) +
    pubkeyHashN +
    sigs;

  const tx = helpers.sealTransaction(txSkeleton, [sigs]);
  const hash = await rpc.sendTransaction(tx, "passthrough");
  console.log("The transaction hash is", hash);

  return hash;
}

// Multisig transfer example
function main() {
  const fromInfo = generateMofNMultisigInfo(2, 2, [ALICE.ARGS, BOB.ARGS, CHARLES.ARGS]);
  const privKeys = [ALICE.PRIVATE_KEY, BOB.PRIVATE_KEY];
  transfer({ fromInfo, toAddress: TO_ADDRESS, amount: BI.from(8800000000), privKeys });
}

main();
